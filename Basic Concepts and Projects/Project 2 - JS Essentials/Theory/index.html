<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 2</title>
</head>

<body>
    <script>
        // String
        let language = "Javascript";
        let message = `Let's learn ${language}`;
        console.log(message); // Let's learn Javascript

        // Escape characters
        let str = "Hello, what's your name? Is it \"Mike\"?";
        console.log(str);
        let str2 = 'Hello, what\'s your name? Is it "Mike"?';
        console.log(str2);

        let str3 = "New \nline.";
        let str4 = "A backslash: \\!";
        console.log(str3);
        console.log(str4);

        // BigInt
        let a = 10;
        // The limits of the number data type are between 2^53-1 and -(2^53-1)

        // for larger numbers use BigInt data type. It can be recognized by the postfix n
        let bigNr = 90071992547409921n;
        console.log(bigNr);

        // Note: We cannot mix BigInt with the Number data type to perform operations. This is something to keep in mind for later when actually working with BigIntâ€”you can only operate on BigInt with other BigInts.

        // Symbol
        let strr1 = "JavaScript is fun!";
        let strr2 = "JavaScript is fun!";
        console.log("These two strings are the same:", strr1 === strr2); // true
        // Symbol can be used when it is important that variables are not equal, even though their value and type are the same.
        let sym1 = Symbol("JavaScript is fun!");
        let sym2 = Symbol("JavaScript is fun!");
        console.log("These two Symbols are the same:", sym1 === sym2); // false
        // In the first half, JS concludes that the strings are the same. They have the same value, and the same type. However, in the second part, each symbol is unique. Therefore, although they contain the same string, they are nor the same, and output false when compared.

        // Undefined
        let unassigned;
        console.log(unassigned); // undefined

        let dontDoThis = undefined; // AVOID declaring a variable as undefined!

        // null
        let empty = null;
        // null is a special value for saying that a variable is empty or has an unknown value

        let lastName;
        console.log("Same undefined: ", lastName === dontDoThis); // true

        let betterOption = null;
        console.log("Same null: ", lastName === betterOption); // false

        // Working out the type of a variable
        testVar = 1;
        varTypeTest1 = typeof testVar;
        varTypeTest2 = typeof(testVar);
        console.log(varTypeTest1); // number
        console.log(varTypeTest2); // number

        // Brackets aren't required because technically, typeof is an operator, not a method, unlike console.log

        let str_ = "hello";
        let nr = 7;
        let bigNr_ = 12345678901234n;
        let bool = true;
        let sym = Symbol("unique");
        let undef = undefined;
        let unknown = null;

        console.log("str_", typeof str_); // string
        console.log("nr", typeof nr); // number
        console.log("bigNr_", typeof bigNr_); // bigint
        console.log("bool", typeof bool); // boolean
        console.log("sym", typeof sym); // symbol
        console.log("undef", typeof undef); // undefined
        console.log("unknown", typeof unknown); // object

        // In the output typeof null returns object, while in fact, null truly is a primitive and not an object. This is a bug that has been there since forever and now cannot be removed due to backward compatibility problems.

        

    </script>
</body>

</html>